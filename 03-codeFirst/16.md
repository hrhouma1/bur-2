# Concepts du cours DAO / EF en vulgarisation

## 1) **Annotations**

Les annotations sont des **petits mots-clés** que tu écris directement au-dessus de ta classe ou de tes propriétés pour donner des instructions à Entity Framework (EF).
Imagine que tu colles un **Post-it** sur un tiroir pour dire « Ceci est le tiroir principal » ou « Ce tiroir doit contenir au maximum 20 caractères ».
Dans le code, ça donne par exemple :

* `[Key]` → ça indique la clé primaire (identifiant unique du compte).
* `[Required]` → ça dit que la valeur ne peut pas être vide.
* `[MaxLength(20)]` → ça fixe une limite de longueur pour un champ texte.
* `[Column("C_Numero")]` → ça précise le vrai nom de la colonne en base.

Avec les annotations, pas besoin d’aller configurer ta base à la main : le code dit à EF comment créer la table SQL. C’est pratique, mais attention : si tu veux des réglages très complexes (plusieurs clés, relations compliquées), ça devient limité. Là, on passera au **Fluent API**.



## 2) **LINQ (Language Integrated Query)**

LINQ, c’est un langage qui permet de **poser des questions** à tes données directement dans C#.
Au lieu d’écrire des boucles `foreach` à rallonge, tu peux dire :

* « Donne-moi tous les comptes dont le solde est supérieur à 100 ».
* « Calcule la moyenne de tous les soldes ».

Exemple :

```csharp
var comptesRiches = comptes.Where(c => c.Solde > 100);
```

C’est comme si C# intégrait un **mini-Excel** dans ton code : tu peux filtrer, trier, compter, faire des sommes.
Ce qu’il faut retenir :

* **Différé** = la requête n’est pas exécutée tant que tu n’as pas demandé les résultats (ex: `ToList()` déclenche l’exécution).
* **Immédiat** = tu forces l’exécution (ex: `Count()`, `Sum()`).
  LINQ marche à la fois sur des **listes en mémoire** et sur des **tables en base via EF** (on appelle ça LINQ to Entities).



## 3) **DTO (Data Transfer Object)**

Un DTO, c’est une **boîte simplifiée** qui contient uniquement les informations dont tu as besoin pour transmettre des données, par exemple vers une interface utilisateur ou une API.
Imagine que tu as un gros classeur de comptes avec 50 colonnes, mais que tu veux juste donner à ton collègue le **numéro et le solde**. Tu ne vas pas lui photocopier les 50 pages, tu fais une **fiche résumée**.
C’est ça, un DTO.

Exemple :

```csharp
public class CompteDto {
   public string Numero { get; set; }
   public float Solde { get; set; }
}
```

Ensuite, dans ton code :

```csharp
var dto = new CompteDto { Numero = compte.Numero, Solde = compte.Solde };
```

C’est utile car :

* ça protège tes données sensibles (tu ne donnes pas tout),
* ça évite de trop charger la mémoire,
* ça fait une couche de séparation claire entre le **modèle interne** et ce que tu montres à l’extérieur.



## 4) **Fluent API**

Le Fluent API, c’est une **façon plus puissante et flexible** de configurer ta base que les annotations.
Au lieu d’écrire les règles directement dans ta classe avec des Post-it (annotations), tu as un **bureau de contrôle central** (dans `ContextEf`, méthode `OnModelCreating`) où tu définis toutes les règles.
Exemple :

```csharp
modelBuilder.Entity<Compte>()
    .ToTable("T_Comptes", "dbo")
    .Property(c => c.Numero)
    .HasColumnName("C_Numero")
    .HasMaxLength(20)
    .IsRequired();
```

C’est comme si tu avais un **manuel de construction** pour ta maison, séparé des pièces elles-mêmes. Tu peux dire :

* quel est le nom exact de la table,
* quelles colonnes sont obligatoires,
* la longueur maximale,
* et même les relations entre plusieurs tables.

Avantage : tout est centralisé, et c’est plus complet. Inconvénient : c’est un peu plus verbeux à lire.



## 5) **Seed (initialisation de données)**

Le “seed” (graine en anglais), c’est l’action de **planter des données de départ** dans ta base quand tu la crées.
Exemple : quand tu ouvres une nouvelle application bancaire, tu veux avoir déjà **quelques comptes de test** pour jouer.
Avec EF, tu peux créer une classe `InitCompte` qui insère automatiquement 7 comptes (101 à 107) dans ta table.
C’est comme un **kit de démarrage** pour ta base : tu n’as pas besoin de saisir manuellement les données après la création.

Exemple :

```csharp
protected override void Seed(ContextEf ctx){
    ctx.CompteEntities.Add(new Compte("101", DateTime.Now, 100));
    ctx.SaveChanges();
}
```

Ça permet de tester immédiatement ton code CRUD (Create, Read, Update, Delete) sans perdre du temps à remplir à la main.

